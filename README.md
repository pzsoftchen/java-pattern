## head first 案例实践

### 第01章 策略模式
设计原则
    
    1. 发现变化并封装变化
    2. 针对接口（超类型）编程而不针对具体实现编程
    3. 多用组合少用继承

继承的缺陷
    
    1. 代码在子类中重复
    2. 运行时的行为不容易改变
    3. 很难知道所有子类的行为
    4. 改变会牵一发而动全身，造成其他子类不需要的改变

例：

父类：鸭子类

子类：绿头鸭，红头鸭，橡皮鸭

行为：有的鸭子能飞，有的鸭子不能飞；不同的鸭子叫声不同

分析：

    1. 行为是可能扩展的是经常变化的，因此要将行为和鸭子分离开（发现变化并分离封装变化）
    2. 将行为作用于具体鸭子之上，采用组合而不是继承的方式（多用组合少用继承）
    3. 行为存在多样性因此需要将行为定义成抽象的利用多态实现运行时的行为可控（针对超类型编程）


策略模式
    
    定义了算法族，分别封装起来，让它们之间可以相互替换，此模式将算法的变化独立与使用算法的客体，使其能够自由组合替换

    算法族：鸭子的行为
    使用算法的客体：鸭子类


![策略UML类图](http://processon.com/chart_image/5a5818d8e4b0abe85d503f47.png)    
    
### 第02章 观察者模式

设计原则

    1. 发现变化并封装变化
    2. 针对接口（超类型）编程而不针对具体实现编程
    3. 多用组合少用继承
    4. 为交互对象之间的松耦合设计而努力（新）

例：

气象站的需求

气象站搜集气象数据（温度，湿度，气压等），布告板在气象数据发生变化时，跟随着变化


报纸和杂志社的订阅模型
1. 报社的业务出版报纸
2. 向某家报社订阅报纸，只要有新的报纸出版，就会给你送来，只要你是他们的订户，你就会一直收到新的报纸
3. 当你不想再看报纸时，取消订阅，他们就不会再送新的报纸来
4. 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或者取消订阅报纸

观察者模式
    
    在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新

    
![观察者模式UML类图](https://processon.com/chart_image/5a59ce79e4b0c090523f6e8d.png)    

### 第03章 装饰者模式
设计原则

    1. 发现变化并封装变化
    2. 针对接口（超类型）编程而不针对具体实现编程
    3. 多用组合少用继承
    4. 为交互对象之间的松耦合设计而努力
    5. 类应该对扩展开放，对修改关闭（新）
    
装饰者模式
   
    动态的将责任附加到对象身上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案  
      
例：
  星巴兹咖啡店的，咖啡种类和各种添加材料
  咖啡的种类：DarkRoast, Decaf, Espresso,HouseBlend ...
  调料的种类：Milk, Mocha, Soy, Whip ...

如果采用继承的方式，由咖啡的种类和调料的种类组合出来的类数量庞大，而且每增加一种咖啡，其面临和调料组织而来的类难以估计，维护及其困难  
     
![装饰者模式UML类图](http://processon.com/chart_image/5a5b1508e4b0abe85d5480c8.png)



### 第04章

### 第05章



### 第06章

### 第07章

### 第08章


### 第09章

### 第10章

### 第11章


### 第12章

### 第13章

